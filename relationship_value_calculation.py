import torchimport jsonimport mathimport csvimport randomimport numpy as npdef get_relationship_value():    st = [0, 57669, 80909, 157712, 240495, 249493, 315653, 364100, 450517, 522657, 602657, 624610]    ed = [57668, 80908, 157711, 240494, 249492, 315652, 364099, 450516, 522656, 602656, 624609, 665297]    weights = torch.load("total_global_llava665k_hidden_state.pt")    num = 665298    weight_part = []    weight_block = []    length = []    mix_st = []    labels_pred = torch.load("labels_pred.pt")    labels_pred = torch.cat(labels_pred)    print(labels_pred.shape)    block_number = torch.max(labels_pred).item()    s = torch.load("informativeness.pt")    labels_pred -= 1    _res = []    _avg = []    _block = []    _block_s = []    _sum_val = []    _sum_num = []    representativeness = torch.tensor([0.] * num)    uniqueness = torch.tensor([0.] * num)    __avg = torch.tensor([0.] * 4096)    print("Start init!!!")    for i in range(0, block_number):        _res.append([])        _block.append([])        _block_s.append([])        _avg.append(torch.tensor([0.] * 4096))        _sum_val.append(0)        _sum_num.append(0)        print("Start arrange!!!")    for k in range(0, num):        _res[labels_pred[k]].append(k)        _block[labels_pred[k]].append(weights[k].tolist())        _block_s[labels_pred[k]].append(s[k])        _avg[labels_pred[k]] += weights[k]        __avg += weights[k]        _sum_val[labels_pred[k]] += s[k]        _sum_num[labels_pred[k]] += 1           __avg /= num    _norm = torch.tensor([0.] * block_number)    for i in range(0, block_number):        for k in range(0, 4096):            _avg[i][k] = _avg[i][k] / len(_res[i])        _norm[i] = torch.norm(_avg[i] - __avg)        _sum_val[i] /= _sum_num[i]            print("Start calculate representativeness")    belongl = torch.tensor([0] * block_number)    _sd1 = torch.tensor([0.] * block_number)    for i in range(0, block_number):        for j in range(0, 12):            if (_res[i][0] >= st[j] and _res[i][0] <=ed[j]):                belongl[i] = j    print(belongl)    def cal(a, b):        return torch.dot(a,b) / torch.norm(a) / torch.norm(b)            for i in range(0, block_number):        sum1 = 0.        sum2 = 0.        for j in range(0, block_number):            if (i != j) and (belongl[i] == belongl[j]):                sum1 += math.exp(cal(_avg[i], _avg[j]))                sum2 += 1.        _sd1[i] = sum1 / sum2            for i in range(0, num):        representativeness[i] = _sd1[labels_pred[i]] * s[i]                        torch.save(representativeness, "representativeness.pt")        print("Start calculate uniqueness")    for j in range(0, block_number):        block_s = torch.tensor(_block_s[j])        torch_block = torch.tensor(_block[j])        distance = torch.cdist(torch_block, torch_block, p = 2)             s_block = []        for pos_i in range(0, _sum_num[j]):            i = _res[j][pos_i]            s_block.append(s[i])        s_block = torch.tensor(s_block)        avg_distance = torch.sum(distance) / _sum_num[j]        for pos_i in range(0, _sum_num[j]):            i = _res[j][pos_i]            uniqueness[i] = torch.sum(distance[pos_i] * s_block) / avg_distance          torch.save(uniqueness, "uniqueness.pt")if __name__ == '__main__':    get_relationship_value()