from time import timeimport numpy as npfrom scipy.cluster.hierarchy import linkage, fclusterfrom sklearn.datasets import make_blobsfrom sklearn.metrics.cluster import adjusted_mutual_info_scoreimport matplotlib.pyplot as pltimport torchimport jsonimport mathfrom datetime import datetimeimport csvimport randomimport matplotlib.pyplot as pltfrom scipy.optimize import curve_fitdef extract_upper_triangle(distance_matrix_np):    n = distance_matrix_np.shape[0]    pdist_array = np.empty((n * (n - 1)) // 2)    idx = 0    for i in range(n):        for j in range(i + 1, n):            pdist_array[idx] = distance_matrix_np[i, j]            idx += 1    return pdist_arraydef get_posture(x, y, n):    return x * n - x * (x + 1) // 2 + y - x - 1def get_distance(distance_matrix_np):    n = distance_matrix_np.shape[0]    pdist_array = np.empty((n * (n - 1)) // 2)    idx = 0    for i in range(n):        for j in range(i + 1, n):            pdist_array[idx] = distance_matrix_np[i, j]            idx += 1    return pdist_arraydef output(avg_value, save_name, json_info, num, block_number, belong):    print(save_name)        sorted_indices = sorted(avg_value, key=lambda tup: tup[1], reverse=True)        selected_indices = []    final_num = int(num * 0.075)    for i in range(0, final_num):        selected_indices.append(sorted_indices[i][0])    sum_block = torch.tensor([0.] * block_number)    cluster_block = torch.tensor([0.] * block_number)    for i in range(0, final_num):        sum_block[belong[sorted_indices[i][0]]] += 1;    for i in range(0, num):        cluster_block[belong[sorted_indices[i][0]]] += 1            for i in range(0, block_number):        print(i, sum_block[i] / cluster_block[i])            selected_indices = sorted(selected_indices)    save_info=[json_info[i] for i in selected_indices]    with open(save_name + ".json", 'w') as fp:        json.dump(save_info, fp, indent=4)def work(X, Y):    linear_coeffs = np.polyfit(X, Y, 1)    linear_fit = np.polyval(linear_coeffs, X)    quad_coeffs = np.polyfit(X, Y, 2)    quad_fit = np.polyval(quad_coeffs, X)        def log_func(X, a, b):        return a * np.log(b * X)    log_coeffs, _ = curve_fit(log_func, X, Y)    log_fit = log_func(X, *log_coeffs)    def calc_std(y_true, y_pred):        return np.std(y_true - y_pred)    linear_std = calc_std(Y, linear_fit)    quad_std = calc_std(Y, quad_fit)    log_std = calc_std(Y, log_fit)    print(f"Linear fit: Y = {linear_coeffs[0]:.5f}X + {linear_coeffs[1]:.5f}, Std: {linear_std:.5f}")    print(f"Quadratic fit: Y = {quad_coeffs[0]:.5f}X^2 + {quad_coeffs[1]:.5f}X + {quad_coeffs[2]:.5f}, Std: {quad_std:.5f}")    print(f"Logarithmic fit: Y = {log_coeffs[0]:.5f} * log({log_coeffs[1]:.5f}X), Std: {log_std:.5f}")    plt.scatter(X, Y, label='Data')    plt.plot(X, linear_fit, label=f'Linear Fit (Std: {linear_std:.2f})', color='red')    plt.plot(X, quad_fit, label=f'Quadratic Fit (Std: {quad_std:.2f})', color='blue')    plt.plot(X, log_fit, label=f'Logarithmic Fit (Std: {log_std:.2f})', color='purple')    plt.legend()def get_relationship_value(load_name_weights, load_name_clustering, v):    print(datetime.now())#    weights = torch.load("total_global_llava665k_hidden_state.pt")#    self_weight = torch.load("self_weight_4096.pt")#    weights = weights / (weights.std(dim=1, keepdim=True) + 1e-6)#    weights = self_weight * weights#    torch.save(weights, "logits.pt")#    print(weights[0])#    weights = torch.load("logits.pt")#    weight = torch.load("total_global_llava665k_hidden_state.pt")#    import random#    lab = torch.load("check0250.pt")#    print(lab)#    w = []#    for i in range(1, torch.max(lab) + 1):#        print(torch.mean(weight[torch.nonzero(lab == i)], axis = 0))#        print(torch.nonzero(lab == i))#        print(torch.nonzero(lab == i).shape)#        w.append(torch.mean(weight[torch.nonzero(lab == i)], axis = 0)[0])#    ans = []#    for i in range(1, torch.max(lab) + 1):#        ans.append(0.)#        print(w[i - 1].shape)#        for j in range(1, torch.max(lab) + 1):#            if (i != j):#                ans[i - 1] += math.exp(torch.dot(w[i - 1], w[j - 1]) / torch.norm(w[i - 1]) / torch.norm(w[j - 1])) * (torch.nonzero(lab == j).shape[0])#        print(ans[i - 1] / (62000 - (torch.nonzero(lab == i).shape[0])))#        #    for i in range(0, 62000):#        if (i % 1000 ==0):#            print(lab[i])#    exit(0)#    import random#    weights = torch.load("logits.pt")#    weight = torch.load("total_global_llava665k_hidden_state.pt")#    for i in range(0, 400):#        array = torch.arange(i * 1000, i * 1000 + 1000)#        random_numbers1 = array[torch.randperm(len(array))[:100]]#        random_numbers2 = array[torch.randperm(len(array))[:100]]#        print(torch.norm(torch.mean(weights[random_numbers1], axis = 0) - torch.mean(weights[random_numbers2], axis = 0)))#        print(torch.norm(torch.mean(weight[random_numbers1], axis = 0) - torch.mean(weight[random_numbers2], axis = 0)))#        print(torch.norm(weights[array[0]] - torch.mean(weights[random_numbers2], axis = 0)))#        print(torch.norm(weight[array[0]]- torch.mean(weight[random_numbers2], axis = 0)))#        print(torch.norm(weights[array[0]+200000] - torch.mean(weights[random_numbers2], axis = 0)))#        print(torch.norm(weight[array[0]+200000]- torch.mean(weight[random_numbers2], axis = 0)))#        print("-------")#    exit(0)    st = [0, 57669, 80909, 157712, 240495, 249493, 315653, 364100, 450517, 522657, 602657, 624610]    ed = [57668, 80908, 157711, 240494, 249492, 315652, 364099, 450516, 522656, 602656, 624609, 665297] #57668    weights = torch.load("total_global_llava665k_hidden_state.pt")    num = 665298    weight_part = []    weight_block = []    length = []    mix_st = []        labels_pred = torch.load("label_0.1_dis.pt")    labels_pred = torch.cat(labels_pred)    print(labels_pred)    block_number = torch.max(labels_pred).item()        print(labels_pred)    print(torch.max(labels_pred).item())    print(torch.min(labels_pred).item())        s_d_dot = torch.tensor([0.] * num)    s_d_cha = torch.tensor([0.] * num)    s_d_dot_ = torch.tensor([0.] * num)    s_d_cha_ = torch.tensor([0.] * num)    s_d1 = torch.tensor([0.] * num)    s_d2 = torch.tensor([0.] * num)    s_d3 = torch.tensor([0.] * num)    s_d4 = torch.tensor([0.] * num)    s_d5 = torch.tensor([0.] * num)    s_d6 = torch.tensor([0.] * num)    s_n1 = torch.tensor([0.] * num)    s_n2 = torch.tensor([0.] * num)    s_n3 = torch.tensor([0.] * num)#    s = torch.tensor([1.] * num)#    s = torch.load("s1.pt") / torch.log(torch.load("l1.pt"))    s = torch.load("s1.pt")    print(s)    labels_pred -= 1    _res = []    _avg = []    _block = []    _block_s = []    _sum_val = []    _sum_num = []    s_d_group_dot = []    s_d_group_cha = []    s_d_group_dot_ = []    s_d_group_cha_ = []    __avg = torch.tensor([0.] * 4096)    print("Start init!!!")    for i in range(0, block_number):        _res.append([])        _block.append([])        _block_s.append([])        _avg.append(torch.tensor([0.] * 4096))        _sum_val.append(0)        _sum_num.append(0)        print("Start arrange!!!")    for k in range(0, num):        _res[labels_pred[k]].append(k)        _block[labels_pred[k]].append(weights[k].tolist())        _block_s[labels_pred[k]].append(s[k])        _avg[labels_pred[k]] += weights[k]        __avg += weights[k]        _sum_val[labels_pred[k]] += s[k]        _sum_num[labels_pred[k]] += 1           __avg /= num    print("s: ", s)    _norm = torch.tensor([0.] * block_number)    for i in range(0, block_number):        for k in range(0, 4096):            _avg[i][k] = _avg[i][k] / len(_res[i])        _norm[i] = torch.norm(_avg[i] - __avg)        _sum_val[i] /= _sum_num[i]            print("Start calculate 2")    belongl = torch.tensor([0] * block_number)    _sd1 = torch.tensor([0.] * block_number)    _sd2 = torch.tensor([0.] * block_number)    inf1 = torch.tensor([0.] * 12)    inf2 = torch.tensor([0.] * 12)    inf3 = torch.tensor([0.] * 12)    for i in range(0, block_number):        for j in range(0, 12):            if (_res[i][0] >= st[j] and _res[i][0] <=ed[j]):                belongl[i] = j    print(belongl)    def cal(a, b):        return torch.dot(a,b) / torch.norm(a) / torch.norm(b)            for i in range(0, block_number):        sum1 = 0.        sum2 = 0.        sum3 = 0.        sum4 = 0.        for j in range(0, block_number):            if (i != j) and (belongl[i] == belongl[j]):                sum1 += math.exp(cal(_avg[i], _avg[j]))                sum2 += math.exp(cal(_avg[i], _avg[j])) * _sum_num[j]                sum3 += 1.                sum4 += _sum_num[j]        sum1 /= sum3        sum2 /= sum4        inf1[belongl[i]] += sum1        inf2[belongl[i]] += sum2        inf3[belongl[i]] += 1.        _sd1[i] = sum1        _sd2[i] = sum2    for i in range(0, block_number):        _sd1[i] /= inf1[belongl[i]] / inf3[belongl[i]]        _sd2[i] /= inf2[belongl[i]] / inf3[belongl[i]]            for i in range(0, num):        s_d1[i] = _sd1[labels_pred[i]] * s[i]        s_d2[i] = _sd2[labels_pred[i]] * s[i]        s_d3[i] = _sd1[labels_pred[i]] * _sum_val[labels_pred[i]]        s_d4[i] = _sd2[labels_pred[i]] * _sum_val[labels_pred[i]]                        torch.save(s_d1, "010sd1.pt")    torch.save(s_d2, "010sd2.pt")    torch.save(s_d3, "010sd3.pt")    torch.save(s_d4, "010sd4.pt")#    import random#    for i in range(0, block_number):#        print(_sum_num[i], _avg[i])#        print(torch.mean(weight[_res[i]], dim = 0))#    _distance = torch.cdist(torch.stack(_avg), torch.stack(_avg), p = 2)#    for i in range(0, block_number):#        s_d_i_dot = 0.#        s_d_i_cha = 0.#        for j in range(0, block_number):#            s_d_i_cha += _norm[j] / (_norm[j] + _distance[i][j])* _sum_val[j] / _sum_num[j]#            s_d_i_dot += math.exp(- torch.dot(_avg[i], _avg[j]) / torch.norm(_avg[i]) / torch.norm(_avg[j]))* _sum_val[j] / _sum_num[j]#        s_d_i_cha = s_d_i_cha /(block_number - 1) #        s_d_i_dot = s_d_i_dot /(block_number - 1) #        s_d_group_cha.append(s_d_i_cha)#        s_d_group_dot.append(s_d_i_dot)#        s_d_group_cha_.append(s_d_i_cha)#        s_d_group_dot_.append(s_d_i_dot)#        print(i, _sum_num[i])   #    for i in range(0, num):#        s_d_cha[i] = s_d_group_cha[labels_pred[i]]#        s_d_dot[i] = s_d_group_dot[labels_pred[i]]#        s_d_cha_[i] = s_d_group_cha_[labels_pred[i]]#        s_d_dot_[i] = s_d_group_dot_[labels_pred[i]]#    print("Start calculate 2")#    for j in range(0, block_number):#        block_s = torch.tensor(_block_s[j])#        torch_block = torch.tensor(_block[j])#        distance_block = torch.cdist(torch_block, torch.stack(_avg))#        distance_to_avg = []#        distance_to_avg_mul_s = []#        s_block = []#        for pos_i in range(0, _sum_num[j]):#            i = _res[j][pos_i]#            distance_to_avg.append(torch.norm(weights[i] - _avg[j]))#            s_block.append(s[i])       #        distance_to_avg = torch.tensor(distance_to_avg)#        s_block = torch.tensor(s_block)       #        sum1 = 0.#        sum2 = 0.#        sum3 = 0.#        for pos_i in range(0, _sum_num[j]):#            i = _res[j][pos_i]#            s_d1[i] = math.exp(-torch.dot(_avg[j], weights[i]) / torch.norm(_avg[j]) / torch.norm(weights[i]))#            for k in range(0, block_number):#                if (k != j):##                    v1 = math.exp(-torch.dot(_avg[k], weights[i]) / torch.norm(_avg[k]) / torch.norm(weights[i])) * _sum_num[k]##                    v2 = torch.norm(_avg[k] - weights[i]) * _sum_num[k]##                    v3 = torch.norm(_avg[k] - weights[i]) / (torch.norm(weights[i]-_avg[j]) + torch.norm(_avg[k] - _avg[j])) * _sum_num[k]#                    dist_i_k = torch.norm(_avg[k] - weights[i])#                    dist_i_j = torch.norm(_avg[j] - weights[i])#                    dist_j_k = torch.norm(_avg[j] - _avg[k])#                    #                    v1 = dist_i_k / (dist_i_j + dist_j_k) * _sum_num[k]#                    v2 = dist_j_k / (dist_i_k + dist_i_j) * _sum_num[k]#                    v3 = dist_i_j / (dist_j_k + dist_i_k) * _sum_num[k]#                    v4 = dist_i_k / dist_j_k * _sum_num[k]#                    v5 = dist_j_k / dist_i_k * _sum_num[k]#                    v6 = dist_i_k / dist_i_j * _sum_num[k]##                    v4 = dist_i_j / (dist_i_j + dist_j_k)##                    v5 = dist_j_k / (dist_i_j + dist_j_k)##                    v6 = dist_j_k / (dist_i_j + dist_j_k)#                    s_d1[i] += v1 * _sum_val[j]#                    s_d2[i] += v2 * _sum_val[j]#                    s_d3[i] += v3 * _sum_val[j]#                    s_d4[i] += v4 * _sum_val[j]#                    s_d5[i] += v5 * _sum_val[j]#                    s_d6[i] += v6 * _sum_val[j]##                    s_d4[i] += v1 * _sum_val[j]##                    s_d5[i] += v2 * _sum_val[j]##                    s_d6[i] += v3 * _sum_val[j]##                    sum1 += torch.norm(_avg[k] - weights[i])##                    sum2 += torch.norm(weights[i]-_avg[j])##                    sum3 += torch.norm(_avg[k] - _avg[j])#            s_d1[i] /= num - _sum_num[j]#            s_d2[i] /= num - _sum_num[j]#            s_d3[i] /= num - _sum_num[j]#            s_d4[i] /= num - _sum_num[j]#            s_d5[i] /= num - _sum_num[j]#            s_d6[i] /= num - _sum_num[j]##        sum1 /= num - _sum_num[j]##        sum2 /= num - _sum_num[j]##        sum3 /= num - _sum_num[j]##        sum1 /= _sum_num[j]##        sum2 /= _sum_num[j]##        sum3 /= _sum_num[j]                   #        print(j, _sum_num[j], sum1, sum2, sum3)        #    torch.save(s_d1, "sd3.pt")#    torch.save(s_d2, "sd4.pt")#    torch.save(s_d3, "sd5.pt")#    torch.save(s_d4, "sd6.pt")#    torch.save(s_d5, "sd7.pt")#    torch.save(s_d6, "sd8.pt")#    exit(0)        print("Start calculate 3")    for j in range(0, block_number):        block_s = torch.tensor(_block_s[j])        torch_block = torch.tensor(_block[j])        distance = torch.cdist(torch_block, torch_block, p = 2)             distance_to_avg = []        s_block = []        for pos_i in range(0, _sum_num[j]):            i = _res[j][pos_i]            distance_to_avg.append(torch.norm(weights[i] - _avg[j]))            s_block.append(s[i])#                distance_to_avg = torch.tensor(distance_to_avg)        s_block = torch.tensor(s_block)                avg_distance = torch.sum(distance) / _sum_num[j]        for pos_i in range(0, _sum_num[j]):            i = _res[j][pos_i]#            s_n1[i] = distance_to_avg[pos_i] * torch.sum(s_block / (distance[pos_i] + distance_to_avg))#            s_n1[i] = s_n1[i] / _sum_num[j]            #            s_n2[i] = torch.sum(s_block * distance_to_avg / (distance_to_avg + distance[pos_i]))#            s_n2[i] = s_n2[i] / _sum_num[j]#            s_n1[i] = torch.sum(distance[pos_i] / (distance[pos_i] + distance_to_avg) * s_block) / _sum_num[j]#            s_n1[i] = torch.sum(distance[pos_i] / (distance[pos_i] + distance_to_avg) * s_block)#            s_n2[i] = torch.dot(_avg[j], weights[i]) / torch.norm(_avg[j]) / torch.norm(weights[i])            s_n1[i] = torch.sum(distance[pos_i] * s_block) / avg_distance            s_n2[i] = torch.sum(distance[pos_i] * s[i]) / avg_distance               print(s_n1)        print(s_n2)        print(j, _sum_num[j])      #    torch.save(s, "_storage_s_st.pt")#    torch.save(s_d, "storage_d_st_dot.pt")#    torch.save(s_d_cha, "_s_d_cha__.pt")#    torch.save(s_d_dot, "_s_d_dot__.pt")#    torch.save(s_d_cha_, "_s_d_cha_.pt")#    torch.save(s_d_dot_, "_s_d_dot_.pt")    torch.save(s_n1, "010sn_sj.pt")    torch.save(s_n2, "010sn_si.pt")    exit(0)def get_instance_value():    instance_file = 'instance_level_value_all_665k.pt'    v = torch.load(instance_file)    return vif __name__ == '__main__':#    a = torch.load('total_clustering_global_llava665k_hidden_state_split.pt')#    b = torch.load('total_clustering_global_llava665k_hidden_state.pt')#    print(a)#    print(b)    load_name_weights = "total_global_llava665k_hidden_state.pt"    load_name_clustering = "total_clustering_global_llava665k_hidden_state_split_1000.pt"#    v = get_instance_value()    v = []    print("Start data selection!!!")    get_relationship_value(load_name_weights, load_name_clustering, v)